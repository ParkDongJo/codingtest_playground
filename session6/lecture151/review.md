# 강의 듣기 전 문제풀이해보기

N, K, M, V, C 가 모두 단순 반복문으로 풀기, DP 로 풀기에는 범위가 넓다.

- 최대 무게에 포함되는 것만 걸러낸다.
- 그 목록을 가격 기준으로 정렬한다.
- 가방의 개수 만큼만 더한다.

# 강의 해설

- 무게를 적게 담을수 있는 가방부터 오름차순
- 보석을 무게가 적은 것 부터 오름차순

- 순차적으로 가방에 보석을 순차적으로 넣어본다, 그 중에 가장 큰! 보석을 가방에 담는다.
- 담으면, 그 다음 가방으로 이 작업을 반복한다.

## 내 풀이가 틀린 이유!!!

아래 두 코드는 **같은 문제(보석 n개, 가방 k개에서 각 가방에 1개씩 넣어 가치 합 최대)**를 푸는 방식이 “성능” 이전에 문제 해법 자체가 다릅니다. 결론부터 말하면:
• 2풀이(정렬 + 우선순위큐): 이 문제의 표준 해법이고 정확하며 시간 효율도 좋음
• 1풀이: 현재 코드 형태로는 문제를 제대로 풀지 못합니다(로직/입력/반복 모두 문제가 있음) → 성능 비교 자체가 성립하기 어려움

⸻

1풀이가 왜 문제를 못 푸는지 (정확성/구현 관점) 1. 가방이 k개인데 c를 한 번만 입력받음

cin >> c;

문제는 보통 가방 용량이 k개 들어오는데, 1풀이에서는 가방 용량을 하나만 읽습니다. 2. 가방에 맞는 보석을 “한 번만” 필터링

if (t.first <= c) bags.push_back(t);

이건 “용량 c인 가방 1개” 기준 필터링이고, 여러 가방을 고려하지 않습니다. 3. 가치 정렬 방향도 최대화가 아니라 최소화

return a.second < b.second; // 오름차순

최대 합을 원하면 큰 가치부터 골라야 하므로 보통 내림차순이어야 합니다(또는 뒤에서부터). 4. 가방 개수(k)가 아니라 c만큼 더함

for (int i = 0; i < c; i++) ret += bags[i].second;

c는 용량인데, 이를 “몇 개를 담을지”로 쓰고 있습니다. 또한 bags.size() < c면 바로 런타임 에러 가능.

➡️ 즉, 1풀이는 “최적해”를 구하는 알고리즘이라기보다 문제 조건을 잘못 반영한 코드라서, 2풀이와 효율 비교를 하면 안 되고 먼저 수정/재작성이 필요합니다.

⸻

2풀이의 성능/효율 (정확하고 표준)

핵심 아이디어
• 가방을 작은 용량부터 처리하면서,
• 해당 가방에 들어갈 수 있는 보석(무게 ≤ 가방용량)을 전부 priority_queue(최대 힙)에 넣고,
• 그중 가치가 가장 큰 것을 하나 꺼내 담습니다.

시간 복잡도
• 보석 정렬: O(n log n)
• 가방 정렬: O(k log k)
• 각 보석은 pq에 한 번 push, 최대 한 번 pop: 합쳐서 O((n+k) log n) 정도

➡️ 전체는 보통 O((n+k) log n)로 매우 효율적이며, n, k가 최대 3e5 수준이어도 통과하는 대표 풀이입니다.

메모리
• 보석/가방 저장 O(n+k)
• pq 최악 O(n)
➡️ 총 O(n+k) 수준

⸻

“성능 비교”를 한다면 (수정된 1풀이가 있다고 가정할 때)

만약 1풀이를 “각 가방마다 들어갈 수 있는 보석 중 최대 가치 선택” 같은 방식으로 제대로 고친다 해도:
• 가방마다 후보를 매번 탐색하면 최악 O(nk)가 되어 터집니다.
• 후보를 정렬/관리하려면 결국 2풀이처럼 **정렬 + 자료구조(pq or multiset)**로 가게 됩니다.

즉, 이 문제는 구조상 2풀이 방식(또는 유사한 자료구조 기반)이 사실상 정답급입니다.

⸻

결론
• 2풀이: 정확 + 고효율 (추천)
• 1풀이: 현재는 문제를 틀리게 풂(입력/로직/반복/정렬 방향 모두 문제) → 성능 비교 대상이 아님

원하면, 1풀이를 “정확한 다른 방법(예: multiset 사용 / 투포인터+multiset / pq 변형)”으로 진짜 2번째 풀이와 다른 정답 코드로 고쳐서, 그 두 방법(둘 다 정답)끼리 시간/메모리/상수항까지 비교해줄게요.
